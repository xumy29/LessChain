// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.2 <0.9.0;

/**
 * @title timeBeacon
 * @dev Store & retrieve ContractTB variable
 * @custom:dev-run-script ./scripts/deploy_with_ethers.ts
 */


struct ContractTB {
    uint32 shardID;
    uint64 height;
    string blockHash;
    string txHash;
    string statusHash;
}

struct ContractSignedTB {
    ContractTB tb;
    bytes[][] sigs;
    address[] signers;
}

contract TBStorage {
    uint32 minSigCnt; // the minimum number of signatures required for multi-signature
    uint32 shardNum;
    mapping(uint32 => mapping(uint64 => ContractTB)) public tbs;
    mapping(address => uint32) public addr2Shard;
    mapping(address => bool) public addrRecorded; 

    event LogMessage(string message, uint32 shardID, uint64 height, address addr);

    // store ContractTBs of the genesis block
    constructor(ContractTB[] memory genesisTBs, uint32 _minSigCnt, 
                uint32 _shardNum, address[][] memory addrs) {
        for (uint32 shardID = 0; shardID < genesisTBs.length; shardID++) {
            tbs[shardID][0] = genesisTBs[shardID];
            // initial known addresses
            for (uint32 i = 0; i < addrs[shardID].length; i++) {
                address addr = addrs[shardID][i];
                addr2Shard[addr] = shardID;
                addrRecorded[addr] = true;
            }
        }
        minSigCnt = _minSigCnt;
        shardNum = _shardNum;
    }

    // store ContractTB of specific shard and height
    function addTB(ContractTB memory tb, bytes[] memory sigs, bytes[] memory vrfs, 
                    uint64 seedHeight, address[] memory signers) public {
        // verify every signature until validSigCnt reaches minSigCnt
        uint32 validSigCnt = 0;
        // get the block hash corresponding to seedHeight, as seed of vrf
        bytes32 seed = blockhash(seedHeight);
        for (uint32 i = 0; i < sigs.length; i++) {
            // step 0. check that the signer is recorded in contract, and is in the right shard
            if (!addrRecorded[signers[i]]) {
                emit LogMessage("addTB... address not recorded", tb.shardID, tb.height, signers[i]);
                continue;
            }
            if (addr2Shard[signers[i]] != tb.shardID) {
                emit LogMessage("addTB... signer not in this shard", tb.shardID, tb.height, signers[i]);
                continue;
            }
            // step 1. check the vrf result is generated by signer
            if (!verifyVrfResult(seed, vrfs[i], signers[i])) {
                emit LogMessage("addTB... vrf verification not passed", tb.shardID, tb.height, signers[i]);
                continue;
            }
            // step2. check that the vrfValue is qualified for being a signer
            if (!vrfIsQualified(vrfs[i])) {
                emit LogMessage("addTB... vrf not qualified", tb.shardID, tb.height, signers[i]);
                continue;
            }
            // step 3. verify the signature
            if (verifySignature(tb, sigs[i], signers[i])) {
                validSigCnt++;
                if (validSigCnt >= minSigCnt) {
                    break;
                }
            } else {
                emit LogMessage("addTB... signature verification not passed", tb.shardID, tb.height, signers[i]);
            }
        }

        if (validSigCnt < minSigCnt) {
            emit LogMessage("addTB... insufficient valid signatures", tb.shardID, tb.height, address(0));
        } else {
            emit LogMessage("addTB", tb.shardID, tb.height, address(0));
            tbs[tb.shardID][tb.height] = tb;
        }

        // require(validSigCnt >= minSigCnt, "Insufficient valid signatures");
    }

    function vrfIsQualified(bytes memory vrfValue) internal pure returns (bool) {
        return uint8(vrfValue[0]) >= 0;
    }

    // called after committee reconfiguration
    // update the new mapping of address to shardID
    // need to verify the vrfs
    function adjustRecordedAddrs(address[] memory addrs, bytes[] memory vrfs, uint64 seedHeight) public {
        // get the block hash corresponding to seedHeight, as seed of vrf
        bytes32 seed = blockhash(seedHeight);
        
        for (uint32 j = 0; j < addrs.length; j++) {
            address addr = addrs[j];
            bytes memory vrfValue = vrfs[j];
            if (!addrRecorded[addr]) {
                emit LogMessage("adjustAddr... address not recorded", 0, 0, addr);
                continue;
            }
            if (!verifyVrfResult(seed, vrfValue, addr)) {
                emit LogMessage("adjustAddr... vrf verification not passed", 0, 0, addr);
                continue;
            }
            uint32 newShardID = vrfValue2ShardID(vrfValue);
            // adjust addr to new shard
            addr2Shard[addr] = newShardID;
        }
        
    }

    function vrfValue2ShardID(bytes memory vrfValue) internal view returns (uint32) {
        // only support to maximum 256 shards
        return uint8(vrfValue[0]) % shardNum;
    }

    function verifyVrfResult(bytes32 seed, bytes memory vrfValue, 
                        address signer) internal pure returns (bool) {
        // check that the vrfValue is generated by the signer
        (bytes32 r, bytes32 s, uint8 v) = decomposeSig(vrfValue);

        address recoveredSigner = ecrecover(seed, v, r, s);

        return recoveredSigner == signer;
    }


    // Verify signature of ContractTB
    function verifySignature(ContractTB memory tb, bytes memory sig, address signer) internal pure returns (bool) {
        // abi-encode and Keccak-256 hash
        bytes memory encoded = abi.encode(tb.shardID, tb.height, tb.blockHash, tb.txHash, tb.statusHash);
        bytes32 msgHash = keccak256(encoded);

        // Extract r, s, and v values from the signature
        (bytes32 r, bytes32 s, uint8 v) = decomposeSig(sig);

        // Recover the public key from the signature
        address recoveredSigner = ecrecover(msgHash, v, r, s);

        return recoveredSigner == signer;
    }


    function decomposeSig(bytes memory sig) internal pure returns (bytes32, bytes32, uint8) {
        // Extract r, s, and v values from the signature
        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }
        if (v < 27) {
            v = v + 27;
        }

        return (r, s, v);
    }

    // retrieve ContractTB of specific shard and height
    function getTB(uint32 shardID, uint64 height) public returns (ContractTB memory tb){
        emit LogMessage("getTB", shardID, height, address(0));
        return tbs[shardID][height];
    }
    
}
